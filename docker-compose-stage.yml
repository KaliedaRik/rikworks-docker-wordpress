# To use this template:

# replace NAMESPACE with the namespace of your choice
# - should allow different wordpress projects to run on the same dockerised server/machine
# - (though that will also require changing the port that one of the projects listens on)

# for security, the WORDPRESS_ and MYSQL_ environment variables should be changed
# - except WORDPRESS_DB_HOST

# record the namespace used in the toolchain/environment.js file
# - any changes to the compose.yml filename also need to be recorded in environment.js

# invocation, from project root folder:
# $ docker-compose -f [compose-file].yml -d
# or even:
# $ docker-compose -f [compose-file] up -d --force-recreate --build

# (This is all handled automatically when using the toolchain/watch.js functionality)

version: '2'

services:
  wordpress-data:
    container_name: NAMESPACE-wp-data
    build: ./dockerfiles/volume-wp
    image: NAMESPACE-wp-data-image
    restart: never

  db-data:
    container_name: NAMESPACE-db-data
    build: ./dockerfiles/volume-db
    image: NAMESPACE-db-data-image
    restart: never

  db:
    container_name: NAMESPACE-db
    build: ./dockerfiles/container-db
    image: NAMESPACE-db-image
    restart: always
    volumes:
      - NAMESPACE-db-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: wordpress
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

  wordpress:
    container_name: NAMESPACE-wp
    depends_on:
      - db
    build: .
    image: NAMESPACE-wp-image
    links:
      - db
    restart: always
    volumes:
      - NAMESPACE-wp-data:/var/www/html
    ports:
      - "80:80"
    environment:
      WORDPRESS_DB_HOST: db:3306
      WORDPRESS_DB_PASSWORD: wordpress

volumes:
  NAMESPACE-wp-data:
    external: false
  NAMESPACE-db-data:
    external: false
